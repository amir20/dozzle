package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"time"

	"github.com/amir20/dozzle/graph/model"
	"github.com/amir20/dozzle/internal/container"
	"github.com/amir20/dozzle/internal/notification"
	"github.com/amir20/dozzle/internal/notification/dispatcher"
	"github.com/expr-lang/expr"
	"github.com/expr-lang/expr/vm"
)

// Labels is the resolver for the labels field.
func (r *containerResolver) Labels(ctx context.Context, obj *container.Container) (map[string]any, error) {
	result := make(map[string]any)
	for k, v := range obj.Labels {
		result[k] = v
	}
	return result, nil
}

// ID is the resolver for the id field.
func (r *logEventResolver) ID(ctx context.Context, obj *container.LogEvent) (int32, error) {
	return int32(obj.Id), nil
}

// Type is the resolver for the type field.
func (r *logEventResolver) Type(ctx context.Context, obj *container.LogEvent) (*string, error) {
	t := string(obj.Type)
	return &t, nil
}

// CreateNotificationRule is the resolver for the createNotificationRule field.
func (r *mutationResolver) CreateNotificationRule(ctx context.Context, input model.NotificationRuleInput) (*model.NotificationRule, error) {
	sub := &notification.Subscription{
		Name:                input.Name,
		Enabled:             input.Enabled,
		DispatcherID:        int(input.DispatcherID),
		LogExpression:       input.LogExpression,
		ContainerExpression: input.ContainerExpression,
	}

	if err := r.HostService.AddSubscription(sub); err != nil {
		return nil, err
	}

	return subscriptionToNotificationRule(sub, r.HostService.Dispatchers()), nil
}

// UpdateNotificationRule is the resolver for the updateNotificationRule field.
func (r *mutationResolver) UpdateNotificationRule(ctx context.Context, id int32, input model.NotificationRuleUpdateInput) (*model.NotificationRule, error) {
	updates := make(map[string]any)
	if input.Name != nil {
		updates["name"] = *input.Name
	}
	if input.Enabled != nil {
		updates["enabled"] = *input.Enabled
	}
	if input.DispatcherID != nil {
		updates["dispatcherId"] = int(*input.DispatcherID)
	}
	if input.LogExpression != nil {
		updates["logExpression"] = *input.LogExpression
	}
	if input.ContainerExpression != nil {
		updates["containerExpression"] = *input.ContainerExpression
	}

	if err := r.HostService.UpdateSubscription(int(id), updates); err != nil {
		return nil, err
	}

	// Fetch the updated subscription
	dispatchers := r.HostService.Dispatchers()
	for _, sub := range r.HostService.Subscriptions() {
		if sub.ID == int(id) {
			return subscriptionToNotificationRule(sub, dispatchers), nil
		}
	}

	return nil, nil
}

// ReplaceNotificationRule is the resolver for the replaceNotificationRule field.
func (r *mutationResolver) ReplaceNotificationRule(ctx context.Context, id int32, input model.NotificationRuleInput) (*model.NotificationRule, error) {
	sub := &notification.Subscription{
		ID:                  int(id),
		Name:                input.Name,
		Enabled:             input.Enabled,
		DispatcherID:        int(input.DispatcherID),
		LogExpression:       input.LogExpression,
		ContainerExpression: input.ContainerExpression,
	}

	if err := r.HostService.ReplaceSubscription(sub); err != nil {
		return nil, err
	}

	return subscriptionToNotificationRule(sub, r.HostService.Dispatchers()), nil
}

// DeleteNotificationRule is the resolver for the deleteNotificationRule field.
func (r *mutationResolver) DeleteNotificationRule(ctx context.Context, id int32) (bool, error) {
	r.HostService.RemoveSubscription(int(id))
	return true, nil
}

// CreateDispatcher is the resolver for the createDispatcher field.
func (r *mutationResolver) CreateDispatcher(ctx context.Context, input model.DispatcherInput) (*model.Dispatcher, error) {
	var d dispatcher.Dispatcher
	switch input.Type {
	case "webhook":
		url := ""
		if input.URL != nil {
			url = *input.URL
		}
		d = dispatcher.NewWebhookDispatcher(input.Name, url)
	default:
		return nil, &Error{Message: "unknown dispatcher type"}
	}

	id := r.HostService.AddDispatcher(d)

	return &model.Dispatcher{
		ID:   int32(id),
		Name: input.Name,
		Type: input.Type,
		URL:  input.URL,
	}, nil
}

// UpdateDispatcher is the resolver for the updateDispatcher field.
func (r *mutationResolver) UpdateDispatcher(ctx context.Context, id int32, input model.DispatcherInput) (*model.Dispatcher, error) {
	var d dispatcher.Dispatcher
	switch input.Type {
	case "webhook":
		url := ""
		if input.URL != nil {
			url = *input.URL
		}
		d = dispatcher.NewWebhookDispatcher(input.Name, url)
	default:
		return nil, &Error{Message: "unknown dispatcher type"}
	}

	r.HostService.UpdateDispatcher(int(id), d)

	return &model.Dispatcher{
		ID:   id,
		Name: input.Name,
		Type: input.Type,
		URL:  input.URL,
	}, nil
}

// DeleteDispatcher is the resolver for the deleteDispatcher field.
func (r *mutationResolver) DeleteDispatcher(ctx context.Context, id int32) (bool, error) {
	r.HostService.RemoveDispatcher(int(id))
	return true, nil
}

// PreviewExpression is the resolver for the previewExpression field.
func (r *mutationResolver) PreviewExpression(ctx context.Context, input model.PreviewInput) (*model.PreviewResult, error) {
	result := &model.PreviewResult{
		MatchedContainers: []*container.Container{},
		MatchedLogs:       []*container.LogEvent{},
	}

	// Compile and test container expression
	var containerProgram *vm.Program
	if input.ContainerExpression != "" {
		program, err := expr.Compile(input.ContainerExpression, expr.Env(notification.Container{}))
		if err != nil {
			errStr := err.Error()
			result.ContainerError = &errStr
		} else {
			containerProgram = program
		}
	}

	// Compile and test log expression
	var logProgram *vm.Program
	if input.LogExpression != nil && *input.LogExpression != "" {
		program, err := expr.Compile(*input.LogExpression, expr.Env(notification.Log{}))
		if err != nil {
			errStr := err.Error()
			result.LogError = &errStr
		} else {
			logProgram = program
		}
	}

	// If container expression is valid, find matching running containers
	if containerProgram != nil {
		containers, _ := r.HostService.ListAllContainers(container.ContainerLabels{})
		for _, c := range containers {
			if c.State != "running" {
				continue
			}
			nc := notification.FromContainerModel(c)
			evalResult, err := expr.Run(containerProgram, nc)
			if err != nil {
				continue
			}
			if match, ok := evalResult.(bool); ok && match {
				containerCopy := c
				result.MatchedContainers = append(result.MatchedContainers, &containerCopy)
			}
		}
	}

	// If log expression is valid and we have matching containers, fetch real logs
	if logProgram != nil && len(result.MatchedContainers) > 0 {
		ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
		defer cancel()

		const maxLogs = 10
		totalMatched := 0

		for _, c := range result.MatchedContainers {
			if len(result.MatchedLogs) >= maxLogs {
				break
			}

			containerService, err := r.HostService.FindContainer(c.Host, c.ID, container.ContainerLabels{})
			if err != nil {
				continue
			}

			// Fetch recent logs (last 5 minutes)
			from := time.Now().Add(-5 * time.Minute)
			to := time.Now()

			logChan, err := containerService.LogsBetweenDates(ctx, from, to, container.STDALL)
			if err != nil {
				continue
			}

			for logEvent := range logChan {
				if logEvent == nil {
					continue
				}

				// Convert to notification.Log for expression evaluation
				l := notification.FromLogEvent(*logEvent)
				evalResult, err := expr.Run(logProgram, l)
				if err != nil {
					continue
				}

				if match, ok := evalResult.(bool); ok && match {
					totalMatched++
					if len(result.MatchedLogs) < maxLogs {
						result.MatchedLogs = append(result.MatchedLogs, logEvent)
					}
				}
			}
		}

		result.TotalLogs = int32(totalMatched)
	}

	return result, nil
}

// NotificationRules is the resolver for the notificationRules field.
func (r *queryResolver) NotificationRules(ctx context.Context) ([]*model.NotificationRule, error) {
	subscriptions := r.HostService.Subscriptions()
	dispatchers := r.HostService.Dispatchers()
	rules := make([]*model.NotificationRule, len(subscriptions))
	for i, sub := range subscriptions {
		rules[i] = subscriptionToNotificationRule(sub, dispatchers)
	}
	return rules, nil
}

// NotificationRule is the resolver for the notificationRule field.
func (r *queryResolver) NotificationRule(ctx context.Context, id int32) (*model.NotificationRule, error) {
	dispatchers := r.HostService.Dispatchers()
	for _, sub := range r.HostService.Subscriptions() {
		if sub.ID == int(id) {
			return subscriptionToNotificationRule(sub, dispatchers), nil
		}
	}
	return nil, nil
}

// Dispatchers is the resolver for the dispatchers field.
func (r *queryResolver) Dispatchers(ctx context.Context) ([]*model.Dispatcher, error) {
	dispatchers := r.HostService.Dispatchers()
	result := make([]*model.Dispatcher, len(dispatchers))
	for i, d := range dispatchers {
		result[i] = dispatcherConfigToDispatcher(&d)
	}
	return result, nil
}

// Dispatcher is the resolver for the dispatcher field.
func (r *queryResolver) Dispatcher(ctx context.Context, id int32) (*model.Dispatcher, error) {
	for _, d := range r.HostService.Dispatchers() {
		if d.ID == int(id) {
			return dispatcherConfigToDispatcher(&d), nil
		}
	}
	return nil, nil
}

// Container returns ContainerResolver implementation.
func (r *Resolver) Container() ContainerResolver { return &containerResolver{r} }

// LogEvent returns LogEventResolver implementation.
func (r *Resolver) LogEvent() LogEventResolver { return &logEventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type containerResolver struct{ *Resolver }
type logEventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
