package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"time"

	"github.com/amir20/dozzle/graph/model"
	"github.com/amir20/dozzle/internal/container"
	"github.com/amir20/dozzle/internal/notification"
	"github.com/amir20/dozzle/internal/notification/dispatcher"
	"github.com/amir20/dozzle/internal/releases"
	"github.com/amir20/dozzle/types"
	"github.com/expr-lang/expr"
	"github.com/expr-lang/expr/vm"
)

// Labels is the resolver for the labels field.
func (r *containerResolver) Labels(ctx context.Context, obj *container.Container) (map[string]any, error) {
	result := make(map[string]any)
	for k, v := range obj.Labels {
		result[k] = v
	}
	return result, nil
}

// ID is the resolver for the id field.
func (r *logEventResolver) ID(ctx context.Context, obj *container.LogEvent) (int32, error) {
	return int32(obj.Id), nil
}

// Type is the resolver for the type field.
func (r *logEventResolver) Type(ctx context.Context, obj *container.LogEvent) (*string, error) {
	t := string(obj.Type)
	return &t, nil
}

// CreateNotificationRule is the resolver for the createNotificationRule field.
func (r *mutationResolver) CreateNotificationRule(ctx context.Context, input model.NotificationRuleInput) (*model.NotificationRule, error) {
	sub := &notification.Subscription{
		Name:                input.Name,
		Enabled:             input.Enabled,
		DispatcherID:        int(input.DispatcherID),
		LogExpression:       input.LogExpression,
		ContainerExpression: input.ContainerExpression,
	}

	if err := r.HostService.AddSubscription(sub); err != nil {
		return nil, err
	}

	return subscriptionToNotificationRule(sub, r.HostService.Dispatchers()), nil
}

// UpdateNotificationRule is the resolver for the updateNotificationRule field.
func (r *mutationResolver) UpdateNotificationRule(ctx context.Context, id int32, input model.NotificationRuleUpdateInput) (*model.NotificationRule, error) {
	updates := make(map[string]any)
	if input.Name != nil {
		updates["name"] = *input.Name
	}
	if input.Enabled != nil {
		updates["enabled"] = *input.Enabled
	}
	if input.DispatcherID != nil {
		updates["dispatcherId"] = int(*input.DispatcherID)
	}
	if input.LogExpression != nil {
		updates["logExpression"] = *input.LogExpression
	}
	if input.ContainerExpression != nil {
		updates["containerExpression"] = *input.ContainerExpression
	}

	if err := r.HostService.UpdateSubscription(int(id), updates); err != nil {
		return nil, err
	}

	// Fetch the updated subscription
	dispatchers := r.HostService.Dispatchers()
	for _, sub := range r.HostService.Subscriptions() {
		if sub.ID == int(id) {
			return subscriptionToNotificationRule(sub, dispatchers), nil
		}
	}

	return nil, nil
}

// ReplaceNotificationRule is the resolver for the replaceNotificationRule field.
func (r *mutationResolver) ReplaceNotificationRule(ctx context.Context, id int32, input model.NotificationRuleInput) (*model.NotificationRule, error) {
	sub := &notification.Subscription{
		ID:                  int(id),
		Name:                input.Name,
		Enabled:             input.Enabled,
		DispatcherID:        int(input.DispatcherID),
		LogExpression:       input.LogExpression,
		ContainerExpression: input.ContainerExpression,
	}

	if err := r.HostService.ReplaceSubscription(sub); err != nil {
		return nil, err
	}

	return subscriptionToNotificationRule(sub, r.HostService.Dispatchers()), nil
}

// DeleteNotificationRule is the resolver for the deleteNotificationRule field.
func (r *mutationResolver) DeleteNotificationRule(ctx context.Context, id int32) (bool, error) {
	r.HostService.RemoveSubscription(int(id))
	return true, nil
}

// CreateDispatcher is the resolver for the createDispatcher field.
func (r *mutationResolver) CreateDispatcher(ctx context.Context, input model.DispatcherInput) (*model.Dispatcher, error) {
	var d dispatcher.Dispatcher
	switch input.Type {
	case "webhook":
		url := ""
		if input.URL != nil {
			url = *input.URL
		}
		templateStr := ""
		if input.Template != nil {
			templateStr = *input.Template
		}
		webhook, err := dispatcher.NewWebhookDispatcher(input.Name, url, templateStr)
		if err != nil {
			return nil, &Error{Message: err.Error()}
		}
		d = webhook
	default:
		return nil, &Error{Message: "unknown dispatcher type"}
	}

	id := r.HostService.AddDispatcher(d)

	return &model.Dispatcher{
		ID:       int32(id),
		Name:     input.Name,
		Type:     input.Type,
		URL:      input.URL,
		Template: input.Template,
	}, nil
}

// UpdateDispatcher is the resolver for the updateDispatcher field.
func (r *mutationResolver) UpdateDispatcher(ctx context.Context, id int32, input model.DispatcherInput) (*model.Dispatcher, error) {
	var d dispatcher.Dispatcher
	switch input.Type {
	case "webhook":
		url := ""
		if input.URL != nil {
			url = *input.URL
		}
		templateStr := ""
		if input.Template != nil {
			templateStr = *input.Template
		}
		webhook, err := dispatcher.NewWebhookDispatcher(input.Name, url, templateStr)
		if err != nil {
			return nil, &Error{Message: err.Error()}
		}
		d = webhook
	default:
		return nil, &Error{Message: "unknown dispatcher type"}
	}

	r.HostService.UpdateDispatcher(int(id), d)

	return &model.Dispatcher{
		ID:       id,
		Name:     input.Name,
		Type:     input.Type,
		URL:      input.URL,
		Template: input.Template,
	}, nil
}

// DeleteDispatcher is the resolver for the deleteDispatcher field.
func (r *mutationResolver) DeleteDispatcher(ctx context.Context, id int32) (bool, error) {
	r.HostService.RemoveDispatcher(int(id))
	return true, nil
}

// PreviewExpression is the resolver for the previewExpression field.
func (r *mutationResolver) PreviewExpression(ctx context.Context, input model.PreviewInput) (*model.PreviewResult, error) {
	result := &model.PreviewResult{
		MatchedContainers: []*container.Container{},
		MatchedLogs:       []*container.LogEvent{},
	}

	// Compile and test container expression
	var containerProgram *vm.Program
	if input.ContainerExpression != "" {
		program, err := expr.Compile(input.ContainerExpression, expr.Env(types.NotificationContainer{}))
		if err != nil {
			errStr := err.Error()
			result.ContainerError = &errStr
		} else {
			containerProgram = program
		}
	}

	// Compile and test log expression
	var logProgram *vm.Program
	if input.LogExpression != nil && *input.LogExpression != "" {
		program, err := expr.Compile(*input.LogExpression, expr.Env(types.NotificationLog{}))
		if err != nil {
			errStr := err.Error()
			result.LogError = &errStr
		} else {
			logProgram = program
		}
	}

	// If container expression is valid, find matching running containers
	if containerProgram != nil {
		containers, _ := r.HostService.ListAllContainers(container.ContainerLabels{})
		for _, c := range containers {
			if c.State != "running" {
				continue
			}
			nc := notification.FromContainerModel(c)
			evalResult, err := expr.Run(containerProgram, nc)
			if err != nil {
				continue
			}
			if match, ok := evalResult.(bool); ok && match {
				containerCopy := c
				result.MatchedContainers = append(result.MatchedContainers, &containerCopy)
			}
		}
	}

	// If log expression is valid and we have matching containers, fetch real logs
	if logProgram != nil && len(result.MatchedContainers) > 0 {
		ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
		defer cancel()

		const maxLogs = 10
		totalMatched := 0

		for _, c := range result.MatchedContainers {
			if len(result.MatchedLogs) >= maxLogs {
				break
			}

			containerService, err := r.HostService.FindContainer(c.Host, c.ID, container.ContainerLabels{})
			if err != nil {
				continue
			}

			// Fetch recent logs (last 5 minutes)
			from := time.Now().Add(-5 * time.Minute)
			to := time.Now()

			logChan, err := containerService.LogsBetweenDates(ctx, from, to, container.STDALL)
			if err != nil {
				continue
			}

			for logEvent := range logChan {
				if logEvent == nil {
					continue
				}

				// Convert to notification.Log for expression evaluation
				l := notification.FromLogEvent(*logEvent)
				evalResult, err := expr.Run(logProgram, l)
				if err != nil {
					continue
				}

				if match, ok := evalResult.(bool); ok && match {
					totalMatched++
					if len(result.MatchedLogs) < maxLogs {
						result.MatchedLogs = append(result.MatchedLogs, logEvent)
					}
				}
			}
		}

		result.TotalLogs = int32(totalMatched)
	}

	return result, nil
}

// TestWebhook is the resolver for the testWebhook field.
func (r *mutationResolver) TestWebhook(ctx context.Context, input model.TestWebhookInput) (*model.TestWebhookResult, error) {
	templateStr := ""
	if input.Template != nil {
		templateStr = *input.Template
	}

	webhook, err := dispatcher.NewWebhookDispatcher("test", input.URL, templateStr)
	if err != nil {
		errStr := err.Error()
		return &model.TestWebhookResult{
			Success: false,
			Error:   &errStr,
		}, nil
	}

	// Create a mock notification for testing
	mockNotification := types.Notification{
		ID:        "test-notification",
		Timestamp: time.Now(),
		Container: types.NotificationContainer{
			ID:     "abc123",
			Name:   "test-container",
			Image:  "nginx:latest",
			State:  "running",
			Health: "healthy",
			Host:   "localhost",
			Labels: map[string]string{"env": "test"},
		},
		Log: types.NotificationLog{
			ID:        1,
			Message:   "This is a test log message from Dozzle",
			Timestamp: time.Now().UnixMilli(),
			Level:     "info",
			Stream:    "stdout",
			Type:      "simple",
		},
	}

	result := webhook.SendTest(ctx, mockNotification)

	var statusCode *int32
	if result.StatusCode > 0 {
		sc := int32(result.StatusCode)
		statusCode = &sc
	}

	var errStr *string
	if result.Error != "" {
		errStr = &result.Error
	}

	return &model.TestWebhookResult{
		Success:    result.Success,
		StatusCode: statusCode,
		Error:      errStr,
	}, nil
}

// NotificationRules is the resolver for the notificationRules field.
func (r *queryResolver) NotificationRules(ctx context.Context) ([]*model.NotificationRule, error) {
	subscriptions := r.HostService.Subscriptions()
	dispatchers := r.HostService.Dispatchers()
	rules := make([]*model.NotificationRule, len(subscriptions))
	for i, sub := range subscriptions {
		rules[i] = subscriptionToNotificationRule(sub, dispatchers)
	}
	return rules, nil
}

// NotificationRule is the resolver for the notificationRule field.
func (r *queryResolver) NotificationRule(ctx context.Context, id int32) (*model.NotificationRule, error) {
	dispatchers := r.HostService.Dispatchers()
	for _, sub := range r.HostService.Subscriptions() {
		if sub.ID == int(id) {
			return subscriptionToNotificationRule(sub, dispatchers), nil
		}
	}
	return nil, nil
}

// Dispatchers is the resolver for the dispatchers field.
func (r *queryResolver) Dispatchers(ctx context.Context) ([]*model.Dispatcher, error) {
	dispatchers := r.HostService.Dispatchers()
	result := make([]*model.Dispatcher, len(dispatchers))
	for i, d := range dispatchers {
		result[i] = dispatcherConfigToDispatcher(&d)
	}
	return result, nil
}

// Dispatcher is the resolver for the dispatcher field.
func (r *queryResolver) Dispatcher(ctx context.Context, id int32) (*model.Dispatcher, error) {
	for _, d := range r.HostService.Dispatchers() {
		if d.ID == int(id) {
			return dispatcherConfigToDispatcher(&d), nil
		}
	}
	return nil, nil
}

// Releases is the resolver for the releases field.
func (r *queryResolver) Releases(ctx context.Context) ([]*releases.Release, error) {
	if r.ReleasesFetcher == nil {
		return nil, nil
	}
	result, err := r.ReleasesFetcher()
	if err != nil {
		return nil, err
	}
	// Convert to pointers
	releases := make([]*releases.Release, len(result))
	for i := range result {
		releases[i] = &result[i]
	}
	return releases, nil
}

// MentionsCount is the resolver for the mentionsCount field.
func (r *releaseResolver) MentionsCount(ctx context.Context, obj *releases.Release) (int32, error) {
	return int32(obj.MentionsCount), nil
}

// Features is the resolver for the features field.
func (r *releaseResolver) Features(ctx context.Context, obj *releases.Release) (int32, error) {
	return int32(obj.Features), nil
}

// BugFixes is the resolver for the bugFixes field.
func (r *releaseResolver) BugFixes(ctx context.Context, obj *releases.Release) (int32, error) {
	return int32(obj.BugFixes), nil
}

// Breaking is the resolver for the breaking field.
func (r *releaseResolver) Breaking(ctx context.Context, obj *releases.Release) (int32, error) {
	return int32(obj.Breaking), nil
}

// Container returns ContainerResolver implementation.
func (r *Resolver) Container() ContainerResolver { return &containerResolver{r} }

// LogEvent returns LogEventResolver implementation.
func (r *Resolver) LogEvent() LogEventResolver { return &logEventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Release returns ReleaseResolver implementation.
func (r *Resolver) Release() ReleaseResolver { return &releaseResolver{r} }

type containerResolver struct{ *Resolver }
type logEventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type releaseResolver struct{ *Resolver }
